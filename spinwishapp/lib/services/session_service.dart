import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:spinwishapp/models/dj_session.dart' as dj_models;
import 'package:spinwishapp/models/session.dart';
import 'package:spinwishapp/models/request.dart';
import 'package:spinwishapp/models/user.dart';
import 'package:spinwishapp/services/session_api_service.dart';
import 'package:spinwishapp/services/auth_service.dart';
import 'package:spinwishapp/services/websocket_service.dart';
import 'package:spinwishapp/services/enhanced_queue_service.dart';
import 'package:uuid/uuid.dart';

class SessionService extends ChangeNotifier {
  static final SessionService _instance = SessionService._internal();
  factory SessionService() => _instance;
  SessionService._internal() {
    _initializeWebSocketListeners();
  }

  // Enhanced queue service integration
  final EnhancedQueueService _enhancedQueueService = EnhancedQueueService();

  // Session state
  Session? _currentSession;
  List<Request> _requestQueue = [];
  List<User> _connectedListeners = [];
  double _sessionEarnings = 0.0;
  double _sessionTips = 0.0;
  bool _isConnectEnabled = false;

  // Real-time simulation timers
  Timer? _sessionTimer;
  Timer? _listenerUpdateTimer;
  Timer? _requestSimulationTimer;

  // WebSocket service
  final WebSocketService _webSocketService = WebSocketService();
  StreamSubscription? _sessionUpdateSubscription;
  StreamSubscription? _requestUpdateSubscription;

  // Getters
  Session? get currentSession => _currentSession;
  List<Request> get requestQueue => List.unmodifiable(_requestQueue);
  List<User> get connectedListeners => List.unmodifiable(_connectedListeners);
  double get sessionEarnings => _sessionEarnings;
  double get sessionTips => _sessionTips;
  bool get isConnectEnabled => _isConnectEnabled;
  bool get isSessionActive => _currentSession?.status == SessionStatus.live;
  int get listenerCount => _connectedListeners.length;
  int get pendingRequestsCount =>
      _requestQueue.where((r) => r.status == RequestStatus.pending).length;

  // Start a new session
  Future<Session> startSession({
    required String djId,
    required SessionType type,
    required String title,
    String? description,
    String? clubId,
    String? clubName,
    String? clubAddress,
    List<String> genres = const [],
    double minTipAmount = 1.0,
  }) async {
    try {
      // Get current user info for DJ ID
      final currentUser = await AuthService.getCurrentUser();
      final actualDjId = currentUser?.id ?? djId;

      // Create session object for API
      final sessionToCreate = Session(
        id: '', // Will be generated by backend
        djId: actualDjId,
        clubId: clubId,
        type: type,
        status: SessionStatus.preparing,
        title: title,
        description: description,
        startTime: DateTime.now(),
        listenerCount: 0,
        requestQueue: const [],
        totalEarnings: 0.0,
        totalTips: 0.0,
        totalRequests: 0,
        acceptedRequests: 0,
        rejectedRequests: 0,
        isAcceptingRequests: true,
        minTipAmount: minTipAmount,
        genres: genres,
      );

      // Create session via API
      final createdSession =
          await SessionApiService.createSession(sessionToCreate);

      // Start the session immediately
      _currentSession = await SessionApiService.startSession(createdSession.id);

      // Reset local session data
      _requestQueue.clear();
      _connectedListeners.clear();
      _sessionEarnings = 0.0;
      _sessionTips = 0.0;

      // Start real-time simulation for demo purposes
      _startRealTimeSimulation();

      // Connect to WebSocket for real-time updates
      await connectWebSocket();

      notifyListeners();
      return _currentSession!;
    } catch (e) {
      throw Exception('Failed to start session: ${e.toString()}');
    }
  }

  // End current session
  Future<void> endSession() async {
    if (_currentSession == null) return;

    try {
      // End session via API
      _currentSession = await SessionApiService.endSession(_currentSession!.id);

      // Disconnect from WebSocket
      await disconnectWebSocket();

      // Stop real-time simulation
      _stopRealTimeSimulation();

      // Clear session data
      _requestQueue.clear();
      _connectedListeners.clear();

      notifyListeners();
    } catch (e) {
      throw Exception('Failed to end session: ${e.toString()}');
    }
  }

  // Toggle connect feature
  void toggleConnect(bool enabled) {
    _isConnectEnabled = enabled;

    if (enabled && _currentSession != null) {
      // Start listener simulation when connect is enabled
      _startListenerSimulation();
    } else {
      // Stop listener simulation when connect is disabled
      _stopListenerSimulation();
      _connectedListeners.clear();
    }

    notifyListeners();
  }

  // Accept a song request
  Future<void> acceptRequest(String requestId) async {
    final requestIndex = _requestQueue.indexWhere((r) => r.id == requestId);
    if (requestIndex == -1) return;

    final request = _requestQueue[requestIndex];

    // Simulate API call delay
    await Future.delayed(const Duration(milliseconds: 300));

    // Update request status
    _requestQueue[requestIndex] = Request(
      id: request.id,
      userId: request.userId,
      sessionId: request.sessionId,
      songId: request.songId,
      status: RequestStatus.accepted,
      amount: request.amount,
      timestamp: request.timestamp,
      message: request.message,
    );

    // Add to earnings
    _sessionEarnings += request.amount;

    // Update session stats
    if (_currentSession != null) {
      _currentSession = _currentSession!.copyWith(
        totalEarnings: _sessionEarnings,
        acceptedRequests: (_currentSession!.acceptedRequests ?? 0) + 1,
      );
    }

    notifyListeners();
  }

  // Reject a song request
  Future<void> rejectRequest(String requestId) async {
    final requestIndex = _requestQueue.indexWhere((r) => r.id == requestId);
    if (requestIndex == -1) return;

    final request = _requestQueue[requestIndex];

    // Simulate API call delay
    await Future.delayed(const Duration(milliseconds: 300));

    // Update request status
    _requestQueue[requestIndex] = Request(
      id: request.id,
      userId: request.userId,
      sessionId: request.sessionId,
      songId: request.songId,
      status: RequestStatus.rejected,
      amount: request.amount,
      timestamp: request.timestamp,
      message: request.message,
    );

    // Update session stats
    if (_currentSession != null) {
      _currentSession = _currentSession!.copyWith(
        rejectedRequests: (_currentSession!.rejectedRequests ?? 0) + 1,
      );
    }

    // TODO: Process automatic refund here

    notifyListeners();
  }

  // Fulfill a request (mark as played)
  Future<void> fulfillRequest(String requestId) async {
    final requestIndex = _requestQueue.indexWhere((r) => r.id == requestId);
    if (requestIndex == -1) return;

    final request = _requestQueue[requestIndex];

    // Simulate API call delay
    await Future.delayed(const Duration(milliseconds: 300));

    // Update request status
    _requestQueue[requestIndex] = Request(
      id: request.id,
      userId: request.userId,
      sessionId: request.sessionId,
      songId: request.songId,
      status: RequestStatus.played,
      amount: request.amount,
      timestamp: request.timestamp,
      message: request.message,
    );

    notifyListeners();
  }

  // ===== ENHANCED QUEUE MANAGEMENT METHODS =====

  /// Load priority-ordered queue
  Future<void> loadPriorityQueue() async {
    if (_currentSession == null) return;

    try {
      await _enhancedQueueService.loadPriorityQueue(_currentSession!.djId);

      // Sync with local queue
      _requestQueue = _enhancedQueueService.priorityQueue;
      notifyListeners();
    } catch (e) {
      debugPrint('Failed to load priority queue: $e');
    }
  }

  /// Reorder queue manually
  Future<bool> reorderQueue(List<String> requestIds) async {
    if (_currentSession == null) return false;

    return await _enhancedQueueService.reorderQueue(
        _currentSession!.djId, requestIds);
  }

  /// Check if song is duplicate
  Future<bool> isDuplicateSong(String songId) async {
    if (_currentSession == null) return false;

    return await _enhancedQueueService.isDuplicateSong(
        _currentSession!.djId, songId);
  }

  /// Get queue statistics
  Future<Map<String, Object>> getQueueStatistics() async {
    if (_currentSession == null) return {};

    await _enhancedQueueService.loadQueueStatistics(_currentSession!.djId);
    return _enhancedQueueService.queueStatistics;
  }

  /// Get estimated wait time for a queue position
  Duration getEstimatedWaitTime(int queuePosition) {
    return _enhancedQueueService.getEstimatedWaitTime(queuePosition);
  }

  /// Get queue position for a request
  int? getQueuePosition(String requestId) {
    return _enhancedQueueService.getQueuePosition(requestId);
  }

  /// Calculate priority score for a request
  double calculatePriorityScore(Request request) {
    return _enhancedQueueService.calculatePriorityScore(request);
  }

  // Start real-time simulation
  void _startRealTimeSimulation() {
    // Simulate session updates every 30 seconds
    _sessionTimer = Timer.periodic(const Duration(seconds: 30), (timer) {
      if (_currentSession != null) {
        _currentSession = _currentSession!.copyWith(
          listenerCount: _connectedListeners.length,
          totalEarnings: _sessionEarnings,
          totalTips: _sessionTips,
          totalRequests: _requestQueue.length,
        );
        notifyListeners();
      }
    });

    // Simulate new requests periodically
    if (_isConnectEnabled) {
      _startRequestSimulation();
    }
  }

  void _startListenerSimulation() {
    _listenerUpdateTimer = Timer.periodic(const Duration(seconds: 15), (timer) {
      if (!_isConnectEnabled || _currentSession == null) {
        timer.cancel();
        return;
      }

      final random = Random();

      // Randomly add or remove listeners
      if (random.nextBool() && _connectedListeners.length < 50) {
        _addRandomListener();
      } else if (_connectedListeners.isNotEmpty && random.nextDouble() < 0.3) {
        _removeRandomListener();
      }
    });
  }

  void _startRequestSimulation() {
    _requestSimulationTimer = Timer.periodic(const Duration(seconds: 45), (
      timer,
    ) {
      if (!_isConnectEnabled || _currentSession == null) {
        timer.cancel();
        return;
      }

      final random = Random();
      if (random.nextDouble() < 0.7 && _connectedListeners.isNotEmpty) {
        _addRandomRequest();
      }
    });
  }

  void _stopRealTimeSimulation() {
    _sessionTimer?.cancel();
    _stopListenerSimulation();
    _requestSimulationTimer?.cancel();
  }

  void _stopListenerSimulation() {
    _listenerUpdateTimer?.cancel();
  }

  void _addRandomListener() {
    final random = Random();
    final names = [
      'Alex',
      'Jordan',
      'Casey',
      'Morgan',
      'Riley',
      'Avery',
      'Quinn',
      'Sage',
    ];
    final name = names[random.nextInt(names.length)];

    final listener = User(
      id: const Uuid().v4(),
      name: '$name ${String.fromCharCode(65 + random.nextInt(26))}.',
      email: '${name.toLowerCase()}@example.com',
      profileImage: 'https://api.dicebear.com/7.x/avataaars/svg?seed=$name',
      credits: random.nextDouble() * 100,
      favoriteDJs: [],
      favoriteGenres: [],
    );

    _connectedListeners.add(listener);
    notifyListeners();
  }

  void _removeRandomListener() {
    if (_connectedListeners.isNotEmpty) {
      final random = Random();
      _connectedListeners.removeAt(random.nextInt(_connectedListeners.length));
      notifyListeners();
    }
  }

  void _addRandomRequest() {
    if (_connectedListeners.isEmpty) return;

    final random = Random();
    final songs = [
      'Blinding Lights',
      'Watermelon Sugar',
      'Levitating',
      'Good 4 U',
      'Stay',
      'Industry Baby',
      'Heat Waves',
      'Bad Habits',
      'Shivers',
    ];
    final artists = [
      'The Weeknd',
      'Harry Styles',
      'Dua Lipa',
      'Olivia Rodrigo',
      'The Kid LAROI',
      'Lil Nas X',
      'Glass Animals',
      'Ed Sheeran',
    ];

    final listener =
        _connectedListeners[random.nextInt(_connectedListeners.length)];
    final songTitle = songs[random.nextInt(songs.length)];
    final artist = artists[random.nextInt(artists.length)];
    final tipAmount = (random.nextDouble() * 10 + 1).roundToDouble();

    final request = Request(
      id: const Uuid().v4(),
      userId: listener.id,
      sessionId: _currentSession!.id,
      songId: const Uuid().v4(),
      status: RequestStatus.pending,
      amount: tipAmount,
      timestamp: DateTime.now(),
      message: random.nextBool() ? 'Great song!' : null,
    );

    _requestQueue.insert(0, request);

    if (_currentSession != null) {
      _currentSession = _currentSession!.copyWith(
        totalRequests: (_currentSession!.totalRequests ?? 0) + 1,
      );
    }

    notifyListeners();
  }

  String _generateShareableLink(String sessionId) {
    return 'https://spinwish.app/session/$sessionId';
  }

  // Additional API integration methods

  /// Pause current session
  Future<void> pauseSession() async {
    if (_currentSession == null) return;

    try {
      _currentSession =
          await SessionApiService.pauseSession(_currentSession!.id);
      _stopRealTimeSimulation();
      notifyListeners();
    } catch (e) {
      throw Exception('Failed to pause session: ${e.toString()}');
    }
  }

  /// Resume current session
  Future<void> resumeSession() async {
    if (_currentSession == null) return;

    try {
      _currentSession =
          await SessionApiService.resumeSession(_currentSession!.id);
      _startRealTimeSimulation();
      notifyListeners();
    } catch (e) {
      throw Exception('Failed to resume session: ${e.toString()}');
    }
  }

  /// Update session settings
  Future<void> updateSessionSettings({
    String? title,
    String? description,
    double? minTipAmount,
    bool? isAcceptingRequests,
    List<String>? genres,
  }) async {
    if (_currentSession == null) return;

    try {
      final updatedSession = _currentSession!.copyWith(
        title: title ?? _currentSession!.title,
        description: description ?? _currentSession!.description,
        minTipAmount: minTipAmount ?? _currentSession!.minTipAmount,
        isAcceptingRequests:
            isAcceptingRequests ?? _currentSession!.isAcceptingRequests,
        genres: genres ?? _currentSession!.genres,
      );

      _currentSession = await SessionApiService.updateSession(
          _currentSession!.id, updatedSession);
      notifyListeners();
    } catch (e) {
      throw Exception('Failed to update session settings: ${e.toString()}');
    }
  }

  /// Get current DJ's sessions
  Future<List<Session>> getDJSessions() async {
    try {
      final currentUser = await AuthService.getCurrentUser();
      if (currentUser == null) return [];

      return await SessionApiService.getSessionsByDjId(currentUser.id);
    } catch (e) {
      throw Exception('Failed to fetch DJ sessions: ${e.toString()}');
    }
  }

  /// Get live sessions for listeners
  Future<List<Session>> getLiveSessions() async {
    try {
      return await SessionApiService.getLiveSessions();
    } catch (e) {
      throw Exception('Failed to fetch live sessions: ${e.toString()}');
    }
  }

  /// Get sessions accepting requests
  Future<List<Session>> getSessionsAcceptingRequests() async {
    try {
      return await SessionApiService.getSessionsAcceptingRequests();
    } catch (e) {
      throw Exception(
          'Failed to fetch sessions accepting requests: ${e.toString()}');
    }
  }

  /// Toggle request acceptance for current session
  Future<void> toggleRequestAcceptance() async {
    if (_currentSession == null) return;

    try {
      final newAcceptingState = !(_currentSession!.isAcceptingRequests ?? true);
      _currentSession = await SessionApiService.toggleRequestAcceptance(
        _currentSession!.id,
        newAcceptingState,
      );
      notifyListeners();
    } catch (e) {
      throw Exception('Failed to toggle request acceptance: ${e.toString()}');
    }
  }

  /// Update minimum tip amount for current session
  Future<void> updateMinTipAmount(double minTipAmount) async {
    if (_currentSession == null) return;

    try {
      _currentSession = await SessionApiService.updateMinTipAmount(
        _currentSession!.id,
        minTipAmount,
      );
      notifyListeners();
    } catch (e) {
      throw Exception('Failed to update minimum tip amount: ${e.toString()}');
    }
  }

  /// Load session by ID (for joining existing sessions)
  Future<void> loadSession(String sessionId) async {
    try {
      _currentSession = await SessionApiService.getSessionById(sessionId);

      // Reset local data
      _requestQueue.clear();
      _connectedListeners.clear();
      _sessionEarnings = _currentSession!.totalEarnings ?? 0.0;
      _sessionTips = _currentSession!.totalTips ?? 0.0;

      // Start simulation if session is live
      if (_currentSession!.status == SessionStatus.live) {
        _startRealTimeSimulation();
      }

      // Connect to WebSocket for real-time updates
      await connectWebSocket();

      notifyListeners();
    } catch (e) {
      throw Exception('Failed to load session: ${e.toString()}');
    }
  }

  /// Refresh current session data from API
  Future<void> refreshSession() async {
    if (_currentSession == null) return;

    try {
      _currentSession =
          await SessionApiService.getSessionById(_currentSession!.id);
      notifyListeners();
    } catch (e) {
      throw Exception('Failed to refresh session: ${e.toString()}');
    }
  }

  /// Initialize WebSocket listeners for real-time updates
  void _initializeWebSocketListeners() {
    _sessionUpdateSubscription = _webSocketService.sessionUpdates.listen(
      (updatedSession) {
        if (_currentSession != null &&
            _currentSession!.id == updatedSession.id) {
          _currentSession = updatedSession;
          _sessionEarnings = updatedSession.totalEarnings ?? 0.0;
          _sessionTips = updatedSession.totalTips ?? 0.0;
          notifyListeners();
        }
      },
    );

    _requestUpdateSubscription = _webSocketService.requestUpdates.listen(
      (request) {
        _handleRealTimeRequestUpdate(request);
      },
    );
  }

  /// Handle real-time request updates from WebSocket
  void _handleRealTimeRequestUpdate(Request request) {
    final existingIndex = _requestQueue.indexWhere((r) => r.id == request.id);

    if (existingIndex != -1) {
      // Update existing request
      _requestQueue[existingIndex] = request;
    } else {
      // Add new request
      _requestQueue.insert(0, request);
    }

    // Update session stats if current session matches
    if (_currentSession != null && request.sessionId == _currentSession!.id) {
      _currentSession = _currentSession!.copyWith(
        totalRequests: (_currentSession!.totalRequests ?? 0) +
            (existingIndex == -1 ? 1 : 0),
      );
    }

    notifyListeners();
  }

  /// Connect to WebSocket for real-time updates
  Future<void> connectWebSocket() async {
    try {
      await _webSocketService.connect();

      // Subscribe to current session updates if available
      if (_currentSession != null) {
        _webSocketService.subscribeToSession(_currentSession!.id);

        // Subscribe to requests if user is a DJ
        final currentUser = await AuthService.getCurrentUser();
        if (currentUser != null && currentUser.role == 'DJ') {
          _webSocketService.subscribeToRequests(currentUser.id);
        }
      }
    } catch (e) {
      debugPrint('Failed to connect WebSocket: $e');
    }
  }

  /// Disconnect from WebSocket
  Future<void> disconnectWebSocket() async {
    if (_currentSession != null) {
      _webSocketService.unsubscribeFromSession(_currentSession!.id);

      final currentUser = await AuthService.getCurrentUser();
      if (currentUser != null && currentUser.role == 'DJ') {
        _webSocketService.unsubscribeFromRequests(currentUser.id);
      }
    }

    await _webSocketService.disconnect();
  }

  @override
  void dispose() {
    _stopRealTimeSimulation();
    _sessionUpdateSubscription?.cancel();
    _requestUpdateSubscription?.cancel();
    disconnectWebSocket();
    super.dispose();
  }
}
